import annotation.effects._; import simple._

class t {
  val f81: (() => () => Int) @refine = () => () => 1
  def f82: (() => Int) @refine @infer = f81()
  def v: (() => Int) { def apply(): Int @noEff } = f82
}

class t {
  val f7: (Int => Int) @refine = (x: Int) => x
  def v7(x: Int): Int @noEff = f7(x)
}



class t {
  val f81: (() => () => Int) @refine = () => () => 1
  def f82(): (()=> Int) @refine @infer = f81()
  def f83(): Int @infer = f82()()
  def v82(): Int @noEff = f83()
}




class t {
  val f81: (Int => Int => Int) @refine = (x: Int) => (y: Int) => x
  def f82(x: Int): (Int => Int) @refine @infer = f81(x)
  def f83(x: Int): Int @infer = f82(x)(10)
  def v82(x: Int): Int @noEff = f83(x) // f83 has no latent effect
}


NOTES
=====




BUGS

====


====




TESTS
=====



val f = (x: Int) => (y: Int) => x + y
def g: ((Int) => Int) @refine @infer = f(1) // g: ((Int) => Int){def apply(x$1: Int): Int @eff} @noEff




abstract class C { def f: Int }
def c: C @infer @refine = new C { def f: Int @infer = 1 }
def bar: Int @infer = c.f                                 // infer @eff (`c` has eff, from constructor)
val c1: C @refine = new C { def f: Int @infer = 1 }
def bar1: Int @infer = c1.f                               // infer @noEff


abstract class C { def f: Int }
def foo(c: C) = c.f


object t { val f: (() => Int) { def apply(): Int @eff } = () => 1 }
val g = t.f    // g: (() => Int){def apply(): Int @scala.annotation.effects.simple.eff}



def foo(x: Int): Int @infer = x
def bar: Int @refine = foo(1)
def baz: Int @infer = foo(1)

